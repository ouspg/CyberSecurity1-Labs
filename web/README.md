# Web Hacking

This is the web hacking module for the lab.

This module uses a modified version of the OWASP Juice Shop.

## Configurations

The lab uses a docker compose file to start the juice shop service and passes `juice-shop-config.yml` as the configuration file. You can modify stuff like `title`,`name`,`logo` etc.

For the compose file, it is suggested not to update the environnment variables and volumes as they can cause other things to break.

## Setup

To setup this lab you need to have the modified version of the OWASP juice shop as a docker image.

Pull the docker image:

```bash

```

Convert it into archive. Make sure it exists under the `web` directory:

```
docker image save <>:<>
```

## Modified OWASP Juice Shop

Some of the features of OWASP Juice shop were modified to comply with the course labs. The modified Juice Shop was then converted to a docker image.

### Challenges

By default Owasp Juice shop contains 110 challenges. These were reduced to almost 6 by keeping only the required ones under `juice-shop/data/static/challenges.yml`. These include

1. Score Board
2. DOM XSS
3. Confidential Document
4. Password Strength
5. View Basket
6. User Credentials
7. [Robots.txt](#robotstxt)

### Flag Generation

One of the criteria of these labs was to have the capability to generate dynamic flags for students. OWASP Juice shop already has a [flag generation mechanism when run under CTF mode](https://pwning.owasp-juice.shop/companion-guide/latest/part4/ctf.html).

To synchroninze the flags generated by OWASP Juice Shop and the lab flag generator application under `flag_generator`, the flag generation algorithm in juice shop was updated.

The `ctfFlag` under `juice-shop/lib/utils.ts` is responsible for generating the flags under CTF mode. This function was updated to include the student email, lab id and the challenge key as a base. The algorithm was also updated to create a HMAC SHA256 hash, same as in `flag_generator/app/generator.py`.

```ts
// juice-shop/lib/utils.ts

export const ctfFlag = (challenegeKey: string): string => {
  const email = process.env.EMAIL
  const labId = process.env.LAB_ID
  const base = `${email}|${labId}|${challenegeKey}`
  const secret = getCtfKey()
  const digest = crypto.createHmac('sha256', secret).update(base).digest('hex')
  const truncated = digest.substring(0, 16)
  return `FLAG{${truncated}}`
}
```

Since challenge name is used by default, the caller method `sendNotification` also needed to be updated to pass the challenge key instead of name under `juice-shop/utils/ChallengeUtils.ts`

```ts
// juice-shop/lib/ChallengeUtils.ts

export const sendNotification = function (challenge: { difficulty?: number, key: any, name: any, description?: any }, isRestore: boolean) {
  if (!notSolved(challenge)) {
    const flag = utils.ctfFlag(challenge.key) // <== this was updated
```

Refer to [Flag Generation Logic] to learn more about how the flags are generated.

### Robots.txt

Another quite easy challenge was added where a flag is inserted in the robots.txt under `Crawl Delay`. For this the robots.txt was modified under `juice-shop/server.ts`

```ts
app.use(robots({ UserAgent: '*', Disallow: '/ftp', CrawlDelay: utils.ctfFlag('robotsChallenge') }))
```

### Other Changes

Because the challenges were reduced, the code dependent on those challenges had to be commented out under `juice-shop/data/datacreator.ts`

```ts
// juice-shop/data/datacreator.ts

// This code was commented out in the modifed Juice Shop

if (useForChristmasSpecialChallenge) { datacache.products.christmasSpecial = persistedProduct }
if (urlForProductTamperingChallenge) {
    datacache.products.osaft = persistedProduct
    await datacache.challenges.changeProductChallenge.update({
    description: customizeChangeProductChallenge(
        datacache.challenges.changeProductChallenge.description,
        config.get('challenges.overwriteUrlForProductTamperingChallenge'),
        persistedProduct)
    })
}
if (fileForRetrieveBlueprintChallenge && datacache.challenges.retrieveBlueprintChallenge.hint !== null) {
    await datacache.challenges.retrieveBlueprintChallenge.update({
    hint: customizeRetrieveBlueprintChallenge(
        datacache.challenges.retrieveBlueprintChallenge.hint,
        persistedProduct)
    })
}
```
